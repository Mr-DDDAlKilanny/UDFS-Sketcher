//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 expression.g3 1435-05-29 10:18:21

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Sketcher.Drawing.Expressions
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
internal partial class expressionParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "IDINTIFIER", "LPARN", "NUMBER", "RPARN", "WS", "'!='", "'%'", "'&'", "'*'", "'+'", "','", "'-'", "'/'", "'<'", "'<='", "'='", "'>'", "'>='", "'^'", "'|'"
	};
	public const int EOF=-1;
	public const int IDINTIFIER=4;
	public const int LPARN=5;
	public const int NUMBER=6;
	public const int RPARN=7;
	public const int WS=8;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;

	public expressionParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public expressionParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return expressionParser.tokenNames; } }
	public override string GrammarFileName { get { return "expression.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_compileUnit();
	partial void LeaveRule_compileUnit();
	// $ANTLR start "compileUnit"
	// expression.g3:24:1: public compileUnit : expression EOF ;
	[GrammarRule("compileUnit")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> compileUnit()
	{
		EnterRule_compileUnit();
		EnterRule("compileUnit", 1);
		TraceIn("compileUnit", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken EOF2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree EOF2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "compileUnit");
		DebugLocation(24, 1);
		try
		{
			// expression.g3:25:5: ( expression EOF )
			DebugEnterAlt(1);
			// expression.g3:26:2: expression EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(26, 2);
			PushFollow(Follow._expression_in_compileUnit95);
			expression1=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression1.Tree);
			DebugLocation(27, 2);
			EOF2=(CommonToken)Match(input,EOF,Follow._EOF_in_compileUnit98); if (state.failed) return retval;
			if (state.backtracking == 0) {
			EOF2_tree = (CommonTree)adaptor.Create(EOF2);
			adaptor.AddChild(root_0, EOF2_tree);
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compileUnit", 1);
			LeaveRule("compileUnit", 1);
			LeaveRule_compileUnit();
		}
		DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "compileUnit"); }
		return retval;

	}
	// $ANTLR end "compileUnit"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// expression.g3:30:1: expression : addSubExpr ( ( WS )* ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^) ( WS )* addSubExpr )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 2);
		TraceIn("expression", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken WS4 = default(CommonToken);
		CommonToken char_literal5 = default(CommonToken);
		CommonToken char_literal6 = default(CommonToken);
		CommonToken char_literal7 = default(CommonToken);
		CommonToken char_literal8 = default(CommonToken);
		CommonToken char_literal9 = default(CommonToken);
		CommonToken string_literal10 = default(CommonToken);
		CommonToken string_literal11 = default(CommonToken);
		CommonToken char_literal12 = default(CommonToken);
		CommonToken string_literal13 = default(CommonToken);
		CommonToken WS14 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> addSubExpr3 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> addSubExpr15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree WS4_tree = default(CommonTree);
		CommonTree char_literal5_tree = default(CommonTree);
		CommonTree char_literal6_tree = default(CommonTree);
		CommonTree char_literal7_tree = default(CommonTree);
		CommonTree char_literal8_tree = default(CommonTree);
		CommonTree char_literal9_tree = default(CommonTree);
		CommonTree string_literal10_tree = default(CommonTree);
		CommonTree string_literal11_tree = default(CommonTree);
		CommonTree char_literal12_tree = default(CommonTree);
		CommonTree string_literal13_tree = default(CommonTree);
		CommonTree WS14_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(30, 1);
		try
		{
			// expression.g3:30:11: ( addSubExpr ( ( WS )* ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^) ( WS )* addSubExpr )* )
			DebugEnterAlt(1);
			// expression.g3:31:2: addSubExpr ( ( WS )* ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^) ( WS )* addSubExpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(31, 2);
			PushFollow(Follow._addSubExpr_in_expression108);
			addSubExpr3=addSubExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, addSubExpr3.Tree);
			DebugLocation(31, 13);
			// expression.g3:31:13: ( ( WS )* ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^) ( WS )* addSubExpr )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				try
				{
					alt4 = dfa4.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// expression.g3:31:14: ( WS )* ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^) ( WS )* addSubExpr
					{
					DebugLocation(31, 14);
					// expression.g3:31:14: ( WS )*
					try { DebugEnterSubRule(1);
					while (true)
					{
						int alt1=2;
						try { DebugEnterDecision(1, false);
						int LA1_1 = input.LA(1);

						if ((LA1_1==WS))
						{
							alt1 = 1;
						}


						} finally { DebugExitDecision(1); }
						switch ( alt1 )
						{
						case 1:
							DebugEnterAlt(1);
							// expression.g3:31:14: WS
							{
							DebugLocation(31, 14);
							WS4=(CommonToken)Match(input,WS,Follow._WS_in_expression111); if (state.failed) return retval;
							if (state.backtracking == 0) {
							WS4_tree = (CommonTree)adaptor.Create(WS4);
							adaptor.AddChild(root_0, WS4_tree);
							}

							}
							break;

						default:
							goto loop1;
						}
					}

					loop1:
						;

					} finally { DebugExitSubRule(1); }

					DebugLocation(31, 18);
					// expression.g3:31:18: ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^)
					int alt2=9;
					try { DebugEnterSubRule(2);
					try { DebugEnterDecision(2, false);
					switch (input.LA(1))
					{
					case 11:
						{
						alt2 = 1;
						}
						break;
					case 23:
						{
						alt2 = 2;
						}
						break;
					case 22:
						{
						alt2 = 3;
						}
						break;
					case 17:
						{
						alt2 = 4;
						}
						break;
					case 20:
						{
						alt2 = 5;
						}
						break;
					case 18:
						{
						alt2 = 6;
						}
						break;
					case 21:
						{
						alt2 = 7;
						}
						break;
					case 19:
						{
						alt2 = 8;
						}
						break;
					case 9:
						{
						alt2 = 9;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// expression.g3:31:20: '&' ^
						{
						DebugLocation(31, 23);
						char_literal5=(CommonToken)Match(input,11,Follow._11_in_expression116); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal5_tree = (CommonTree)adaptor.Create(char_literal5);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal5_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// expression.g3:31:27: '|' ^
						{
						DebugLocation(31, 30);
						char_literal6=(CommonToken)Match(input,23,Follow._23_in_expression121); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal6_tree = (CommonTree)adaptor.Create(char_literal6);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal6_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// expression.g3:31:34: '^' ^
						{
						DebugLocation(31, 37);
						char_literal7=(CommonToken)Match(input,22,Follow._22_in_expression126); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal7_tree = (CommonTree)adaptor.Create(char_literal7);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal7_tree, root_0);
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// expression.g3:31:41: '<' ^
						{
						DebugLocation(31, 44);
						char_literal8=(CommonToken)Match(input,17,Follow._17_in_expression131); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal8_tree = (CommonTree)adaptor.Create(char_literal8);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal8_tree, root_0);
						}

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// expression.g3:31:48: '>' ^
						{
						DebugLocation(31, 51);
						char_literal9=(CommonToken)Match(input,20,Follow._20_in_expression136); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal9_tree = (CommonTree)adaptor.Create(char_literal9);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal9_tree, root_0);
						}

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// expression.g3:31:55: '<=' ^
						{
						DebugLocation(31, 59);
						string_literal10=(CommonToken)Match(input,18,Follow._18_in_expression141); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal10_tree = (CommonTree)adaptor.Create(string_literal10);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal10_tree, root_0);
						}

						}
						break;
					case 7:
						DebugEnterAlt(7);
						// expression.g3:31:63: '>=' ^
						{
						DebugLocation(31, 67);
						string_literal11=(CommonToken)Match(input,21,Follow._21_in_expression146); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal11_tree = (CommonTree)adaptor.Create(string_literal11);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal11_tree, root_0);
						}

						}
						break;
					case 8:
						DebugEnterAlt(8);
						// expression.g3:31:71: '=' ^
						{
						DebugLocation(31, 74);
						char_literal12=(CommonToken)Match(input,19,Follow._19_in_expression151); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal12_tree = (CommonTree)adaptor.Create(char_literal12);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal12_tree, root_0);
						}

						}
						break;
					case 9:
						DebugEnterAlt(9);
						// expression.g3:31:78: '!=' ^
						{
						DebugLocation(31, 82);
						string_literal13=(CommonToken)Match(input,9,Follow._9_in_expression156); if (state.failed) return retval;
						if (state.backtracking == 0) {
						string_literal13_tree = (CommonTree)adaptor.Create(string_literal13);
						root_0 = (CommonTree)adaptor.BecomeRoot(string_literal13_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(2); }

					DebugLocation(31, 86);
					// expression.g3:31:86: ( WS )*
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_1 = input.LA(1);

						if ((LA3_1==WS))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch ( alt3 )
						{
						case 1:
							DebugEnterAlt(1);
							// expression.g3:31:86: WS
							{
							DebugLocation(31, 86);
							WS14=(CommonToken)Match(input,WS,Follow._WS_in_expression161); if (state.failed) return retval;
							if (state.backtracking == 0) {
							WS14_tree = (CommonTree)adaptor.Create(WS14);
							adaptor.AddChild(root_0, WS14_tree);
							}

							}
							break;

						default:
							goto loop3;
						}
					}

					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(31, 90);
					PushFollow(Follow._addSubExpr_in_expression164);
					addSubExpr15=addSubExpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, addSubExpr15.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 2);
			LeaveRule("expression", 2);
			LeaveRule_expression();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_addSubExpr();
	partial void LeaveRule_addSubExpr();
	// $ANTLR start "addSubExpr"
	// expression.g3:34:1: addSubExpr : multDivExpr ( ( WS )* ( '+' ^| '-' ^) ( WS )* multDivExpr )* ;
	[GrammarRule("addSubExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> addSubExpr()
	{
		EnterRule_addSubExpr();
		EnterRule("addSubExpr", 3);
		TraceIn("addSubExpr", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken WS17 = default(CommonToken);
		CommonToken char_literal18 = default(CommonToken);
		CommonToken char_literal19 = default(CommonToken);
		CommonToken WS20 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> multDivExpr16 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> multDivExpr21 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree WS17_tree = default(CommonTree);
		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal19_tree = default(CommonTree);
		CommonTree WS20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "addSubExpr");
		DebugLocation(34, 56);
		try
		{
			// expression.g3:35:5: ( multDivExpr ( ( WS )* ( '+' ^| '-' ^) ( WS )* multDivExpr )* )
			DebugEnterAlt(1);
			// expression.g3:35:7: multDivExpr ( ( WS )* ( '+' ^| '-' ^) ( WS )* multDivExpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(35, 7);
			PushFollow(Follow._multDivExpr_in_addSubExpr180);
			multDivExpr16=multDivExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multDivExpr16.Tree);
			DebugLocation(35, 19);
			// expression.g3:35:19: ( ( WS )* ( '+' ^| '-' ^) ( WS )* multDivExpr )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				try
				{
					alt8 = dfa8.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// expression.g3:35:20: ( WS )* ( '+' ^| '-' ^) ( WS )* multDivExpr
					{
					DebugLocation(35, 20);
					// expression.g3:35:20: ( WS )*
					try { DebugEnterSubRule(5);
					while (true)
					{
						int alt5=2;
						try { DebugEnterDecision(5, false);
						int LA5_1 = input.LA(1);

						if ((LA5_1==WS))
						{
							alt5 = 1;
						}


						} finally { DebugExitDecision(5); }
						switch ( alt5 )
						{
						case 1:
							DebugEnterAlt(1);
							// expression.g3:35:20: WS
							{
							DebugLocation(35, 20);
							WS17=(CommonToken)Match(input,WS,Follow._WS_in_addSubExpr183); if (state.failed) return retval;
							if (state.backtracking == 0) {
							WS17_tree = (CommonTree)adaptor.Create(WS17);
							adaptor.AddChild(root_0, WS17_tree);
							}

							}
							break;

						default:
							goto loop5;
						}
					}

					loop5:
						;

					} finally { DebugExitSubRule(5); }

					DebugLocation(35, 24);
					// expression.g3:35:24: ( '+' ^| '-' ^)
					int alt6=2;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if ((LA6_1==13))
					{
						alt6 = 1;
					}
					else if ((LA6_1==15))
					{
						alt6 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// expression.g3:35:26: '+' ^
						{
						DebugLocation(35, 29);
						char_literal18=(CommonToken)Match(input,13,Follow._13_in_addSubExpr188); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal18_tree = (CommonTree)adaptor.Create(char_literal18);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal18_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// expression.g3:35:33: '-' ^
						{
						DebugLocation(35, 36);
						char_literal19=(CommonToken)Match(input,15,Follow._15_in_addSubExpr193); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal19_tree = (CommonTree)adaptor.Create(char_literal19);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal19_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(6); }

					DebugLocation(35, 40);
					// expression.g3:35:40: ( WS )*
					try { DebugEnterSubRule(7);
					while (true)
					{
						int alt7=2;
						try { DebugEnterDecision(7, false);
						int LA7_1 = input.LA(1);

						if ((LA7_1==WS))
						{
							alt7 = 1;
						}


						} finally { DebugExitDecision(7); }
						switch ( alt7 )
						{
						case 1:
							DebugEnterAlt(1);
							// expression.g3:35:40: WS
							{
							DebugLocation(35, 40);
							WS20=(CommonToken)Match(input,WS,Follow._WS_in_addSubExpr198); if (state.failed) return retval;
							if (state.backtracking == 0) {
							WS20_tree = (CommonTree)adaptor.Create(WS20);
							adaptor.AddChild(root_0, WS20_tree);
							}

							}
							break;

						default:
							goto loop7;
						}
					}

					loop7:
						;

					} finally { DebugExitSubRule(7); }

					DebugLocation(35, 44);
					PushFollow(Follow._multDivExpr_in_addSubExpr201);
					multDivExpr21=multDivExpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multDivExpr21.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("addSubExpr", 3);
			LeaveRule("addSubExpr", 3);
			LeaveRule_addSubExpr();
		}
		DebugLocation(35, 56);
		} finally { DebugExitRule(GrammarFileName, "addSubExpr"); }
		return retval;

	}
	// $ANTLR end "addSubExpr"

	partial void EnterRule_multDivExpr();
	partial void LeaveRule_multDivExpr();
	// $ANTLR start "multDivExpr"
	// expression.g3:37:1: multDivExpr : atom ( ( WS )* ( '*' ^| '/' ^| '%' ^) ( WS )* atom )* ;
	[GrammarRule("multDivExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> multDivExpr()
	{
		EnterRule_multDivExpr();
		EnterRule("multDivExpr", 4);
		TraceIn("multDivExpr", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken WS23 = default(CommonToken);
		CommonToken char_literal24 = default(CommonToken);
		CommonToken char_literal25 = default(CommonToken);
		CommonToken char_literal26 = default(CommonToken);
		CommonToken WS27 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> atom22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> atom28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree WS23_tree = default(CommonTree);
		CommonTree char_literal24_tree = default(CommonTree);
		CommonTree char_literal25_tree = default(CommonTree);
		CommonTree char_literal26_tree = default(CommonTree);
		CommonTree WS27_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multDivExpr");
		DebugLocation(37, 47);
		try
		{
			// expression.g3:38:3: ( atom ( ( WS )* ( '*' ^| '/' ^| '%' ^) ( WS )* atom )* )
			DebugEnterAlt(1);
			// expression.g3:38:5: atom ( ( WS )* ( '*' ^| '/' ^| '%' ^) ( WS )* atom )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(38, 5);
			PushFollow(Follow._atom_in_multDivExpr214);
			atom22=atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, atom22.Tree);
			DebugLocation(38, 10);
			// expression.g3:38:10: ( ( WS )* ( '*' ^| '/' ^| '%' ^) ( WS )* atom )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				try
				{
					alt12 = dfa12.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// expression.g3:38:11: ( WS )* ( '*' ^| '/' ^| '%' ^) ( WS )* atom
					{
					DebugLocation(38, 11);
					// expression.g3:38:11: ( WS )*
					try { DebugEnterSubRule(9);
					while (true)
					{
						int alt9=2;
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if ((LA9_1==WS))
						{
							alt9 = 1;
						}


						} finally { DebugExitDecision(9); }
						switch ( alt9 )
						{
						case 1:
							DebugEnterAlt(1);
							// expression.g3:38:11: WS
							{
							DebugLocation(38, 11);
							WS23=(CommonToken)Match(input,WS,Follow._WS_in_multDivExpr217); if (state.failed) return retval;
							if (state.backtracking == 0) {
							WS23_tree = (CommonTree)adaptor.Create(WS23);
							adaptor.AddChild(root_0, WS23_tree);
							}

							}
							break;

						default:
							goto loop9;
						}
					}

					loop9:
						;

					} finally { DebugExitSubRule(9); }

					DebugLocation(38, 15);
					// expression.g3:38:15: ( '*' ^| '/' ^| '%' ^)
					int alt10=3;
					try { DebugEnterSubRule(10);
					try { DebugEnterDecision(10, false);
					switch (input.LA(1))
					{
					case 12:
						{
						alt10 = 1;
						}
						break;
					case 16:
						{
						alt10 = 2;
						}
						break;
					case 10:
						{
						alt10 = 3;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(10); }
					switch (alt10)
					{
					case 1:
						DebugEnterAlt(1);
						// expression.g3:38:17: '*' ^
						{
						DebugLocation(38, 20);
						char_literal24=(CommonToken)Match(input,12,Follow._12_in_multDivExpr222); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal24_tree = (CommonTree)adaptor.Create(char_literal24);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal24_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// expression.g3:38:24: '/' ^
						{
						DebugLocation(38, 27);
						char_literal25=(CommonToken)Match(input,16,Follow._16_in_multDivExpr227); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal25_tree = (CommonTree)adaptor.Create(char_literal25);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal25_tree, root_0);
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// expression.g3:38:31: '%' ^
						{
						DebugLocation(38, 34);
						char_literal26=(CommonToken)Match(input,10,Follow._10_in_multDivExpr232); if (state.failed) return retval;
						if (state.backtracking == 0) {
						char_literal26_tree = (CommonTree)adaptor.Create(char_literal26);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal26_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(10); }

					DebugLocation(38, 38);
					// expression.g3:38:38: ( WS )*
					try { DebugEnterSubRule(11);
					while (true)
					{
						int alt11=2;
						try { DebugEnterDecision(11, false);
						int LA11_1 = input.LA(1);

						if ((LA11_1==WS))
						{
							alt11 = 1;
						}


						} finally { DebugExitDecision(11); }
						switch ( alt11 )
						{
						case 1:
							DebugEnterAlt(1);
							// expression.g3:38:38: WS
							{
							DebugLocation(38, 38);
							WS27=(CommonToken)Match(input,WS,Follow._WS_in_multDivExpr237); if (state.failed) return retval;
							if (state.backtracking == 0) {
							WS27_tree = (CommonTree)adaptor.Create(WS27);
							adaptor.AddChild(root_0, WS27_tree);
							}

							}
							break;

						default:
							goto loop11;
						}
					}

					loop11:
						;

					} finally { DebugExitSubRule(11); }

					DebugLocation(38, 42);
					PushFollow(Follow._atom_in_multDivExpr240);
					atom28=atom();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, atom28.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multDivExpr", 4);
			LeaveRule("multDivExpr", 4);
			LeaveRule_multDivExpr();
		}
		DebugLocation(38, 47);
		} finally { DebugExitRule(GrammarFileName, "multDivExpr"); }
		return retval;

	}
	// $ANTLR end "multDivExpr"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// expression.g3:40:1: atom : ( NUMBER | ( ( IDINTIFIER ( WS )* LPARN )=> functionCall ) | IDINTIFIER | ( LPARN ! expression RPARN !) );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 5);
		TraceIn("atom", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NUMBER29 = default(CommonToken);
		CommonToken IDINTIFIER31 = default(CommonToken);
		CommonToken LPARN32 = default(CommonToken);
		CommonToken RPARN34 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> functionCall30 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expression33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NUMBER29_tree = default(CommonTree);
		CommonTree IDINTIFIER31_tree = default(CommonTree);
		CommonTree LPARN32_tree = default(CommonTree);
		CommonTree RPARN34_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(40, 1);
		try
		{
			// expression.g3:40:5: ( NUMBER | ( ( IDINTIFIER ( WS )* LPARN )=> functionCall ) | IDINTIFIER | ( LPARN ! expression RPARN !) )
			int alt13=4;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case NUMBER:
				{
				alt13 = 1;
				}
				break;
			case IDINTIFIER:
				{
				int LA13_2 = input.LA(2);

				if ((LA13_2==LPARN) && (EvaluatePredicate(synpred1_expression_fragment)))
				{
					alt13 = 2;
				}
				else if ((LA13_2==EOF||(LA13_2>=RPARN && LA13_2<=23)))
				{
					alt13 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPARN:
				{
				alt13 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// expression.g3:41:2: NUMBER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(41, 2);
				NUMBER29=(CommonToken)Match(input,NUMBER,Follow._NUMBER_in_atom250); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NUMBER29_tree = (CommonTree)adaptor.Create(NUMBER29);
				adaptor.AddChild(root_0, NUMBER29_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// expression.g3:42:4: ( ( IDINTIFIER ( WS )* LPARN )=> functionCall )
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(42, 4);
				// expression.g3:42:4: ( ( IDINTIFIER ( WS )* LPARN )=> functionCall )
				DebugEnterAlt(1);
				// expression.g3:42:5: ( IDINTIFIER ( WS )* LPARN )=> functionCall
				{
				DebugLocation(42, 31);
				PushFollow(Follow._functionCall_in_atom267);
				functionCall30=functionCall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionCall30.Tree);

				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// expression.g3:43:4: IDINTIFIER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(43, 4);
				IDINTIFIER31=(CommonToken)Match(input,IDINTIFIER,Follow._IDINTIFIER_in_atom273); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IDINTIFIER31_tree = (CommonTree)adaptor.Create(IDINTIFIER31);
				adaptor.AddChild(root_0, IDINTIFIER31_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// expression.g3:44:4: ( LPARN ! expression RPARN !)
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(44, 4);
				// expression.g3:44:4: ( LPARN ! expression RPARN !)
				DebugEnterAlt(1);
				// expression.g3:44:5: LPARN ! expression RPARN !
				{
				DebugLocation(44, 10);
				LPARN32=(CommonToken)Match(input,LPARN,Follow._LPARN_in_atom279); if (state.failed) return retval;
				DebugLocation(44, 12);
				PushFollow(Follow._expression_in_atom282);
				expression33=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression33.Tree);
				DebugLocation(44, 28);
				RPARN34=(CommonToken)Match(input,RPARN,Follow._RPARN_in_atom284); if (state.failed) return retval;

				}


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 5);
			LeaveRule("atom", 5);
			LeaveRule_atom();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_functionCall();
	partial void LeaveRule_functionCall();
	// $ANTLR start "functionCall"
	// expression.g3:47:1: functionCall : IDINTIFIER LPARN (i+= expression ( ( WS )* ',' ( WS )* i+= expression )* )? RPARN -> ^( IDINTIFIER LPARN ( $i)* ) ;
	[GrammarRule("functionCall")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> functionCall()
	{
		EnterRule_functionCall();
		EnterRule("functionCall", 6);
		TraceIn("functionCall", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken IDINTIFIER35 = default(CommonToken);
		CommonToken LPARN36 = default(CommonToken);
		CommonToken WS37 = default(CommonToken);
		CommonToken char_literal38 = default(CommonToken);
		CommonToken WS39 = default(CommonToken);
		CommonToken RPARN40 = default(CommonToken);
		List<CommonTree> list_i = null;
		AstParserRuleReturnScope<CommonTree, CommonToken> i = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		CommonTree IDINTIFIER35_tree = default(CommonTree);
		CommonTree LPARN36_tree = default(CommonTree);
		CommonTree WS37_tree = default(CommonTree);
		CommonTree char_literal38_tree = default(CommonTree);
		CommonTree WS39_tree = default(CommonTree);
		CommonTree RPARN40_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDINTIFIER=new RewriteRuleITokenStream(adaptor,"token IDINTIFIER");
		RewriteRuleITokenStream stream_LPARN=new RewriteRuleITokenStream(adaptor,"token LPARN");
		RewriteRuleITokenStream stream_WS=new RewriteRuleITokenStream(adaptor,"token WS");
		RewriteRuleITokenStream stream_14=new RewriteRuleITokenStream(adaptor,"token 14");
		RewriteRuleITokenStream stream_RPARN=new RewriteRuleITokenStream(adaptor,"token RPARN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "functionCall");
		DebugLocation(47, 1);
		try
		{
			// expression.g3:47:13: ( IDINTIFIER LPARN (i+= expression ( ( WS )* ',' ( WS )* i+= expression )* )? RPARN -> ^( IDINTIFIER LPARN ( $i)* ) )
			DebugEnterAlt(1);
			// expression.g3:48:2: IDINTIFIER LPARN (i+= expression ( ( WS )* ',' ( WS )* i+= expression )* )? RPARN
			{
			DebugLocation(48, 2);
			IDINTIFIER35=(CommonToken)Match(input,IDINTIFIER,Follow._IDINTIFIER_in_functionCall297); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IDINTIFIER.Add(IDINTIFIER35);

			DebugLocation(48, 13);
			LPARN36=(CommonToken)Match(input,LPARN,Follow._LPARN_in_functionCall299); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPARN.Add(LPARN36);

			DebugLocation(49, 2);
			// expression.g3:49:2: (i+= expression ( ( WS )* ',' ( WS )* i+= expression )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if (((LA17_1>=IDINTIFIER && LA17_1<=NUMBER)))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// expression.g3:49:3: i+= expression ( ( WS )* ',' ( WS )* i+= expression )*
				{
				DebugLocation(49, 4);
				PushFollow(Follow._expression_in_functionCall305);
				i=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(i.Tree);
				if (list_i==null) list_i=new List<CommonTree>();
				list_i.Add(i.Tree);

				DebugLocation(49, 17);
				// expression.g3:49:17: ( ( WS )* ',' ( WS )* i+= expression )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_1 = input.LA(1);

					if ((LA16_1==WS||LA16_1==14))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// expression.g3:49:18: ( WS )* ',' ( WS )* i+= expression
						{
						DebugLocation(49, 18);
						// expression.g3:49:18: ( WS )*
						try { DebugEnterSubRule(14);
						while (true)
						{
							int alt14=2;
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if ((LA14_1==WS))
							{
								alt14 = 1;
							}


							} finally { DebugExitDecision(14); }
							switch ( alt14 )
							{
							case 1:
								DebugEnterAlt(1);
								// expression.g3:49:18: WS
								{
								DebugLocation(49, 18);
								WS37=(CommonToken)Match(input,WS,Follow._WS_in_functionCall308); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_WS.Add(WS37);


								}
								break;

							default:
								goto loop14;
							}
						}

						loop14:
							;

						} finally { DebugExitSubRule(14); }

						DebugLocation(49, 22);
						char_literal38=(CommonToken)Match(input,14,Follow._14_in_functionCall311); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_14.Add(char_literal38);

						DebugLocation(49, 26);
						// expression.g3:49:26: ( WS )*
						try { DebugEnterSubRule(15);
						while (true)
						{
							int alt15=2;
							try { DebugEnterDecision(15, false);
							int LA15_1 = input.LA(1);

							if ((LA15_1==WS))
							{
								alt15 = 1;
							}


							} finally { DebugExitDecision(15); }
							switch ( alt15 )
							{
							case 1:
								DebugEnterAlt(1);
								// expression.g3:49:26: WS
								{
								DebugLocation(49, 26);
								WS39=(CommonToken)Match(input,WS,Follow._WS_in_functionCall313); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_WS.Add(WS39);


								}
								break;

							default:
								goto loop15;
							}
						}

						loop15:
							;

						} finally { DebugExitSubRule(15); }

						DebugLocation(49, 31);
						PushFollow(Follow._expression_in_functionCall318);
						i=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(i.Tree);
						if (list_i==null) list_i=new List<CommonTree>();
						list_i.Add(i.Tree);


						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(50, 2);
			RPARN40=(CommonToken)Match(input,RPARN,Follow._RPARN_in_functionCall325); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPARN.Add(RPARN40);



			{
			// AST REWRITE
			// elements: IDINTIFIER, LPARN, i
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: i
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,"token i",list_i);
			root_0 = (CommonTree)adaptor.Nil();
			// 51:2: -> ^( IDINTIFIER LPARN ( $i)* )
			{
				DebugLocation(51, 5);
				// expression.g3:51:5: ^( IDINTIFIER LPARN ( $i)* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 7);
				root_1 = (CommonTree)adaptor.BecomeRoot(stream_IDINTIFIER.NextNode(), root_1);

				DebugLocation(51, 18);
				adaptor.AddChild(root_1, stream_LPARN.NextNode());
				DebugLocation(51, 25);
				// expression.g3:51:25: ( $i)*
				while ( stream_i.HasNext )
				{
					DebugLocation(51, 25);
					adaptor.AddChild(root_1, stream_i.NextTree());

				}
				stream_i.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionCall", 6);
			LeaveRule("functionCall", 6);
			LeaveRule_functionCall();
		}
		DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "functionCall"); }
		return retval;

	}
	// $ANTLR end "functionCall"

	partial void EnterRule_synpred1_expression_fragment();
	partial void LeaveRule_synpred1_expression_fragment();

	// $ANTLR start synpred1_expression
	private void synpred1_expression_fragment()
	{
		EnterRule_synpred1_expression_fragment();
		EnterRule("synpred1_expression_fragment", 7);
		TraceIn("synpred1_expression_fragment", 7);
		try
		{
			// expression.g3:42:5: ( IDINTIFIER ( WS )* LPARN )
			DebugEnterAlt(1);
			// expression.g3:42:6: IDINTIFIER ( WS )* LPARN
			{
			DebugLocation(42, 6);
			Match(input,IDINTIFIER,Follow._IDINTIFIER_in_synpred1_expression257); if (state.failed) return;
			DebugLocation(42, 17);
			// expression.g3:42:17: ( WS )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==WS))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// expression.g3:42:17: WS
					{
					DebugLocation(42, 17);
					Match(input,WS,Follow._WS_in_synpred1_expression259); if (state.failed) return;

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(42, 21);
			Match(input,LPARN,Follow._LPARN_in_synpred1_expression262); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_expression_fragment", 7);
			LeaveRule("synpred1_expression_fragment", 7);
			LeaveRule_synpred1_expression_fragment();
		}
	}
	// $ANTLR end synpred1_expression
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA4 dfa4;
	private DFA8 dfa8;
	private DFA12 dfa12;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa4 = new DFA4( this );
		dfa8 = new DFA8( this );
		dfa12 = new DFA12( this );
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\x4\xFFFF";
		private const string DFA4_eofS =
			"\x1\x1\x3\xFFFF";
		private const string DFA4_minS =
			"\x1\x7\x1\xFFFF\x1\x8\x1\xFFFF";
		private const string DFA4_maxS =
			"\x1\x17\x1\xFFFF\x1\x17\x1\xFFFF";
		private const string DFA4_acceptS =
			"\x1\xFFFF\x1\x2\x1\xFFFF\x1\x1";
		private const string DFA4_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\x1\x1\x1\x2\x1\x3\x1\xFFFF\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x7\x3",
				"",
				"\x1\x2\x1\x3\x1\xFFFF\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x7\x3",
				""
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "()* loopback of 31:13: ( ( WS )* ( '&' ^| '|' ^| '^' ^| '<' ^| '>' ^| '<=' ^| '>=' ^| '=' ^| '!=' ^) ( WS )* addSubExpr )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA8 : DFA
	{
		private const string DFA8_eotS =
			"\x4\xFFFF";
		private const string DFA8_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA8_minS =
			"\x1\x7\x1\x8\x2\xFFFF";
		private const string DFA8_maxS =
			"\x2\x17\x2\xFFFF";
		private const string DFA8_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA8_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA8_transitionS =
			{
				"\x1\x2\x1\x1\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\x2\x1\x3\x1\xFFFF"+
				"\x7\x2",
				"\x1\x1\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\x2\x1\x3\x1\xFFFF\x7\x2",
				"",
				""
			};

		private static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
		private static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
		private static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
		private static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
		private static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
		private static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
		private static readonly short[][] DFA8_transition;

		static DFA8()
		{
			int numStates = DFA8_transitionS.Length;
			DFA8_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA8_transition[i] = DFA.UnpackEncodedString(DFA8_transitionS[i]);
			}
		}

		public DFA8( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 8;
			this.eot = DFA8_eot;
			this.eof = DFA8_eof;
			this.min = DFA8_min;
			this.max = DFA8_max;
			this.accept = DFA8_accept;
			this.special = DFA8_special;
			this.transition = DFA8_transition;
		}

		public override string Description { get { return "()* loopback of 35:19: ( ( WS )* ( '+' ^| '-' ^) ( WS )* multDivExpr )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA12 : DFA
	{
		private const string DFA12_eotS =
			"\x4\xFFFF";
		private const string DFA12_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA12_minS =
			"\x1\x7\x1\x8\x2\xFFFF";
		private const string DFA12_maxS =
			"\x2\x17\x2\xFFFF";
		private const string DFA12_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA12_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA12_transitionS =
			{
				"\x1\x2\x1\x1\x1\x2\x1\x3\x1\x2\x1\x3\x3\x2\x1\x3\x7\x2",
				"\x1\x1\x1\x2\x1\x3\x1\x2\x1\x3\x3\x2\x1\x3\x7\x2",
				"",
				""
			};

		private static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
		private static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
		private static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
		private static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
		private static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
		private static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
		private static readonly short[][] DFA12_transition;

		static DFA12()
		{
			int numStates = DFA12_transitionS.Length;
			DFA12_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
			}
		}

		public DFA12( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 12;
			this.eot = DFA12_eot;
			this.eof = DFA12_eof;
			this.min = DFA12_min;
			this.max = DFA12_max;
			this.accept = DFA12_accept;
			this.special = DFA12_special;
			this.transition = DFA12_transition;
		}

		public override string Description { get { return "()* loopback of 38:10: ( ( WS )* ( '*' ^| '/' ^| '%' ^) ( WS )* atom )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expression_in_compileUnit95 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_compileUnit98 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addSubExpr_in_expression108 = new BitSet(new ulong[]{0xFE0B02UL});
		public static readonly BitSet _WS_in_expression111 = new BitSet(new ulong[]{0xFE0B00UL});
		public static readonly BitSet _11_in_expression116 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _23_in_expression121 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _22_in_expression126 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _17_in_expression131 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _20_in_expression136 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _18_in_expression141 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _21_in_expression146 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _19_in_expression151 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _9_in_expression156 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _WS_in_expression161 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _addSubExpr_in_expression164 = new BitSet(new ulong[]{0xFE0B02UL});
		public static readonly BitSet _multDivExpr_in_addSubExpr180 = new BitSet(new ulong[]{0xA102UL});
		public static readonly BitSet _WS_in_addSubExpr183 = new BitSet(new ulong[]{0xA100UL});
		public static readonly BitSet _13_in_addSubExpr188 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _15_in_addSubExpr193 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _WS_in_addSubExpr198 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _multDivExpr_in_addSubExpr201 = new BitSet(new ulong[]{0xA102UL});
		public static readonly BitSet _atom_in_multDivExpr214 = new BitSet(new ulong[]{0x11502UL});
		public static readonly BitSet _WS_in_multDivExpr217 = new BitSet(new ulong[]{0x11500UL});
		public static readonly BitSet _12_in_multDivExpr222 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _16_in_multDivExpr227 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _10_in_multDivExpr232 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _WS_in_multDivExpr237 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _atom_in_multDivExpr240 = new BitSet(new ulong[]{0x11502UL});
		public static readonly BitSet _NUMBER_in_atom250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionCall_in_atom267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDINTIFIER_in_atom273 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPARN_in_atom279 = new BitSet(new ulong[]{0x70UL});
		public static readonly BitSet _expression_in_atom282 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _RPARN_in_atom284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDINTIFIER_in_functionCall297 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _LPARN_in_functionCall299 = new BitSet(new ulong[]{0xF0UL});
		public static readonly BitSet _expression_in_functionCall305 = new BitSet(new ulong[]{0x4180UL});
		public static readonly BitSet _WS_in_functionCall308 = new BitSet(new ulong[]{0x4100UL});
		public static readonly BitSet _14_in_functionCall311 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _WS_in_functionCall313 = new BitSet(new ulong[]{0x170UL});
		public static readonly BitSet _expression_in_functionCall318 = new BitSet(new ulong[]{0x4180UL});
		public static readonly BitSet _RPARN_in_functionCall325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDINTIFIER_in_synpred1_expression257 = new BitSet(new ulong[]{0x120UL});
		public static readonly BitSet _WS_in_synpred1_expression259 = new BitSet(new ulong[]{0x120UL});
		public static readonly BitSet _LPARN_in_synpred1_expression262 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Sketcher.Expression
